/**
 * @(#)XRefPanel 2025/11/02
 *
 * ICE Team free software group
 *
 * This file is part of C64 Java Software Emulator.
 * See README for copyright notice.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 */
package sw_emulator.swing;

import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;
import javax.swing.table.AbstractTableModel;
import sw_emulator.software.memory.XRefManager;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import sw_emulator.software.MemoryDasm;
import sw_emulator.swing.main.Carets;
import sw_emulator.swing.main.Option;
import static sw_emulator.swing.main.XRefUIConstants.COLUMN_ADDRESS_WIDTH;
import static sw_emulator.swing.main.XRefUIConstants.COLUMN_CONTEXT_WIDTH;
import static sw_emulator.swing.main.XRefUIConstants.COLUMN_INSTRUCTION_WIDTH;
import static sw_emulator.swing.main.XRefUIConstants.COLUMN_TYPE_WIDTH;

/**
 * Panel to show cross references
 * 
 * @author ice
 */
public class XRefPanel extends javax.swing.JPanel {
  /** Current diplayed address */
  private int currentDisplayedAddress = -1;

  /**
   * Table model
   */
  XRefTableModel tableModel = new XRefTableModel();

  protected XRefManager xrefManager;
  protected RSyntaxTextArea asmTextArea;
  protected Carets carets;
  protected MemoryDasm[] memory;
  protected Option option;

  /**
   * Creates new form XRefPanel
   */
  public XRefPanel() {
    initComponents();
  }

  /**
   * Set up the panel
   *
   * @param xrefManager the xref manager
   * @param asmTextArea the text ares with syntax
   * @param carets the cartes for positions and address
   * @param option the option
   */
  public void setup(XRefManager xrefManager, RSyntaxTextArea asmTextArea, Carets carets, Option option) {
    this.xrefManager = xrefManager;
    this.asmTextArea = asmTextArea;
    this.carets = carets;
    this.option = option;
  }
  
  /**
   * Set the memory to use
   * 
   * @param memory the memory dasm
   */
  public void setMemory(MemoryDasm[] memory) {
    this.memory=memory;
  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    jPanelButton = new javax.swing.JPanel();
    jButtonRefresh = new javax.swing.JButton();
    jButtonClear = new javax.swing.JButton();
    jButtonGoto = new javax.swing.JButton();
    jScrollPaneXRef = new javax.swing.JScrollPane();
    jTableXRef = new javax.swing.JTable();
    setupTable();
    jLabelStatus = new javax.swing.JLabel();

    setLayout(new java.awt.BorderLayout());

    jButtonRefresh.setText("Refresh");
    jButtonRefresh.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonRefreshActionPerformed(evt);
      }
    });
    jPanelButton.add(jButtonRefresh);

    jButtonClear.setText("Clear");
    jButtonClear.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonClearActionPerformed(evt);
      }
    });
    jPanelButton.add(jButtonClear);

    jButtonGoto.setText("Go to Reference");
    jButtonGoto.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        jButtonGotoActionPerformed(evt);
      }
    });
    jPanelButton.add(jButtonGoto);

    add(jPanelButton, java.awt.BorderLayout.NORTH);

    jTableXRef.setAutoCreateRowSorter(true);
    jTableXRef.setModel(tableModel);
    jScrollPaneXRef.setViewportView(jTableXRef);

    add(jScrollPaneXRef, java.awt.BorderLayout.CENTER);

    jLabelStatus.setText("Select an address to see cross-references");
    jLabelStatus.setBorder(javax.swing.BorderFactory.createEmptyBorder(2, 5, 2, 5));
    add(jLabelStatus, java.awt.BorderLayout.PAGE_END);
  }// </editor-fold>//GEN-END:initComponents

  private void jButtonRefreshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRefreshActionPerformed
    refresh();
  }//GEN-LAST:event_jButtonRefreshActionPerformed

  private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
    clear();
  }//GEN-LAST:event_jButtonClearActionPerformed

  private void jButtonGotoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGotoActionPerformed
    navigateToSelectedReference();
  }//GEN-LAST:event_jButtonGotoActionPerformed

  /**
   * Clean the form at initial state
   */
  public void clean() {
    tableModel.clear();
    memory=null;
    jLabelStatus.setText("Select an address to see cross-references");
  }
  
  /**
   * Clear the table
   */
  public void clear() {
    tableModel.clear();
    jLabelStatus.setText("No data to display");
  }

  /**
   * Refresh the references with the last one
   */
  public void refresh() {
    if (currentDisplayedAddress != -1) {
      showXRefsForAddress(currentDisplayedAddress);
    } else {
      jLabelStatus.setText("No address to refresh");
    }
  }

  /**
   * Show the xrefs for the given address
   *
   * @param address the address
   */
  public void showXRefsForAddress(int address) {
    if (xrefManager == null) {
      jLabelStatus.setText("XRefManager not set");
      return;
    }

    if (address == -1) {
      clear();
      jLabelStatus.setText("No address selected");
      return;
    }

    currentDisplayedAddress = address;

    List<XRefManager.XRef> xrefs = xrefManager.getXRefsForAddress(address);
    tableModel.setData(xrefs);

    XRefManager.XRefStats stats = xrefManager.getStatsForAddress(address);
    jLabelStatus.setText(String.format(
            "Showing %d references for address $%04X (R:%d, W:%d, C:%d)",
            stats.totalReferences, address, stats.readCount, stats.writeCount, stats.callCount
    ));
  }

  /**
   * Navigate to the selected reference in text area
   */
  private void navigateToSelectedReference() {
    if (asmTextArea == null) return;

    int selectedRow = jTableXRef.getSelectedRow();
    if (selectedRow == -1) return;    

    // Converti l'indice della vista all'indice del modello (per il sorting)
    int modelRow = jTableXRef.convertRowIndexToModel(selectedRow);
    XRefManager.XRef xref = tableModel.getXRefAt(modelRow);

    if (xref != null) {
      navigateToAddress(xref.sourceAddress);
    }
  }
  
  /**
   * Navigate to the given address in text area
   * 
   * @param addr the address
   */
  private void navigateToAddress(int addr) {
    if (memory==null) return;
    
    int pos=0, actual;
    // try with carets
    if (addr >= 0) {
      pos = carets.getPosition(memory[addr]);

      if (pos != -1) {
        asmTextArea.setCaretPosition(pos);
        asmTextArea.requestFocusInWindow();
        return;
      } else {
        pos = 0;
      }
    }

    // scan all lines for the memory location
    try {
      String preview = asmTextArea.getText();
      String lines[] = preview.split("\\r?\\n");
      for (String line : lines) {
        actual = searchAddress(line.substring(0, Math.min(line.length(), option.maxLabelLength)));
        if (actual == addr) {
          // set preview in the find position  
          asmTextArea.setCaretPosition(pos);
          asmTextArea.requestFocusInWindow();
          break;
        } else {
          pos += line.length() + 1;
        }
      }
    } catch (Exception e) {
      System.err.println();
    }        
  }
  
  /**
   * Search for a memory address (even as label) from the initial passed string
   * 
   * @param initial the initial buffer to search for
   * @return the address or -1 if not find
   */
  protected int searchAddress(String initial) {
    int addr=-1;
    
    try {
      // get the first word of the string
      String str=initial;
      str=str.contains(" ") ? str.split(" ")[0] : str; 
 
      if (str.length()==4) addr=Integer.decode("0x"+str);
      else {
        str=str.contains(":") ? str.split(":")[0] : str;  
        for (MemoryDasm memory : memory) {
          if (str.equals(memory.dasmLocation) || str.equals(memory.userLocation)) {
            addr=memory.address;
            break;      
          }    
        }  
      }
    } catch (Exception e)  {
        System.err.println(e);   
      }    
    
    return addr;
  }
  
  /**
   * Setup table after his creation
   */
  private void setupTable() {    
    if (jTableXRef.getColumnCount() >= 4) {
        jTableXRef.getColumnModel().getColumn(0).setPreferredWidth(COLUMN_TYPE_WIDTH);
        jTableXRef.getColumnModel().getColumn(1).setPreferredWidth(COLUMN_ADDRESS_WIDTH);
        jTableXRef.getColumnModel().getColumn(2).setPreferredWidth(COLUMN_INSTRUCTION_WIDTH);
        jTableXRef.getColumnModel().getColumn(3).setPreferredWidth(COLUMN_CONTEXT_WIDTH);
        
        jTableXRef.getColumnModel().getColumn(0).setMinWidth(40);
        jTableXRef.getColumnModel().getColumn(1).setMinWidth(60);
        jTableXRef.getColumnModel().getColumn(2).setMinWidth(100);
        jTableXRef.getColumnModel().getColumn(3).setMinWidth(80);
    }
    
    jTableXRef.addMouseListener(new MouseAdapter() {
        @Override
        public void mouseClicked(MouseEvent e) {
            if (e.getClickCount() == 2) {
                navigateToSelectedReference();
            }
        }
    });
}
  
  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton jButtonClear;
  private javax.swing.JButton jButtonGoto;
  private javax.swing.JButton jButtonRefresh;
  private javax.swing.JLabel jLabelStatus;
  private javax.swing.JPanel jPanelButton;
  private javax.swing.JScrollPane jScrollPaneXRef;
  private javax.swing.JTable jTableXRef;
  // End of variables declaration//GEN-END:variables
}

/**
 * TableModel per la tabella dei Cross-Reference
 */
class XRefTableModel extends AbstractTableModel {

  private final String[] columnNames = {"Type", "Source Address", "Instruction", "Context"};
  private List<XRefManager.XRef> data = new ArrayList<>();

  @Override
  public int getRowCount() {
    return data.size();
  }

  @Override
  public int getColumnCount() {
    return columnNames.length;
  }

  @Override
  public String getColumnName(int column) {
    return columnNames[column];
  }

  @Override
  public Object getValueAt(int rowIndex, int columnIndex) {
    if (rowIndex >= data.size()) {
      return null;
    }

    XRefManager.XRef xref = data.get(rowIndex);
    switch (columnIndex) {
      case 0:
        return getTypeDisplay(xref.type);
      case 1:
        return String.format("$%04X", xref.sourceAddress);
      case 2:
        return xref.instruction;
      case 3:
        return xref.context != null ? xref.context : "";
      default:
        return null;
    }
  }

  @Override
  public Class<?> getColumnClass(int columnIndex) {
    return String.class;
  }

  /**
   * Get the type for display
   *
   * @param type the type
   * @return the description of type
   */
  private String getTypeDisplay(XRefManager.XRefType type) {
    switch (type) {
      case READ:
        return "READ";
      case WRITE:
        return "WRITE";
      case CALL:
        return "CALL";
      case JUMP:
        return "JUMP";
      case BRANCH:
        return "BRANCH";
      case POINTER:
        return "POINTER";
      case COMPARE:
        return "COMPARE";
      case MODIFY:
        return "MODIFY";
      case BIT_TEST:
        return "BIT TEST";
      default:
        return "UNKNOWN";
    }
  }

  /**
   * Set the data to show
   *
   * @param newData the data
   */
  public void setData(List<XRefManager.XRef> newData) {
    this.data = new ArrayList<>(newData);
    fireTableDataChanged();
  }

  /**
   * Get the xref at row
   *
   * @param row the row
   * @return the xref
   */
  public XRefManager.XRef getXRefAt(int row) {
    if (row >= 0 && row < data.size()) {
      return data.get(row);
    }
    return null;
  }

  /**
   * Clear the table
   */
  public void clear() {
    data.clear();
    fireTableDataChanged();
  }
}
