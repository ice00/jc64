/**
 * @(#)JWizardDialog 2021/12/05
 *
 * ICE Team free software group
 *
 * This file is part of C64 Java Software Emulator.
 * See README for copyright notice.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 */
package sw_emulator.swing;

import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import javax.swing.table.JTableHeader;
import sw_emulator.software.Disassembly;
import sw_emulator.software.MemoryDasm;
import sw_emulator.swing.main.Option;
import sw_emulator.swing.table.DataTableModelMemory;
import sw_emulator.swing.table.MemoryTableCellRenderer;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.KeyStroke;
import javax.swing.UIManager;
import javax.swing.table.TableModel;
import sw_emulator.swing.table.WizardTableCellRenderer;

/**
 *
 * Wizard for assigning < > reference
 * 
 * @author ice
 */
public class JWizardDialog extends javax.swing.JDialog {  
  Option option;    
  MemoryDasm[] memory;
  Disassembly disassembly;
  
  /** Memory cell renderer for table */
  MemoryTableCellRenderer memoryTableCellRenderer=new MemoryTableCellRenderer();

    /** Data table for memory */
  DataTableModelMemory dataTableModelMemoryLow;
  
  /** Data table for memory */
  DataTableModelMemory dataTableModelMemoryHigh;
  
  /** Wizard table cell renderer */
  WizardTableCellRenderer wizardTableCellRenderer;
  
    /**
     * Creates new form JWizardDialog
     */
    public JWizardDialog(java.awt.Frame parent, boolean modal, Option option) {
        super(parent, modal);
        this.option=option;
                
        Shared.framesList.add(this);
                
        dataTableModelMemoryLow=new DataTableModelMemory(option);
        dataTableModelMemoryHigh=new DataTableModelMemory(option);             
        initComponents();
    }
  
    /**
     * Set up the memory
     * 
     * @param memory 
     * @param disassembly the disassembler
     */
    public void setUp(MemoryDasm[] memory, Disassembly disassembly) {
      this.memory=memory;
      this.disassembly=disassembly;
      
      memoryTableCellRenderer.setDisassembly(disassembly);    
        
      dataTableModelMemoryLow.setData(memory);
      dataTableModelMemoryLow.fireTableDataChanged();  
      dataTableModelMemoryHigh.setData(memory);
      dataTableModelMemoryHigh.fireTableDataChanged();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanelUp = new javax.swing.JPanel();
        jLabelWizard = new javax.swing.JLabel();
        jPanelCn = new javax.swing.JPanel();
        jSplitPaneMain = new javax.swing.JSplitPane();
        jPanelMem = new javax.swing.JPanel();
        jPanelFrom = new javax.swing.JPanel();
        jPanelLo = new javax.swing.JPanel();
        jLabelLow = new javax.swing.JLabel();
        jScrollPaneLow = new javax.swing.JScrollPane();
        jTableLow = new javax.swing.JTable() {
            String[] hh={"Memory address location in Hex",
                "Disassembler automatic comment",
                "User manual comment",
                "Disassembler automatic label",
                "User manual label",
                "User global comment",
                "Related location and data type",
                "Value in memory"};
            @Override protected JTableHeader createDefaultTableHeader() {
                return new JTableHeader(columnModel) {
                    @Override public String getToolTipText(MouseEvent e) {
                        int col = columnAtPoint(e.getPoint());
                        int index = columnModel.getColumnIndexAtX(e.getPoint().x);
                        int realIndex = columnModel.getColumn(index).getModelIndex();
                        return hh[realIndex];
                    }
                };
            }

            //Implement table cell tool tips.
            public String getToolTipText(MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int rowIndex = rowAtPoint(p);
                int colIndex = columnAtPoint(p);
                int realColumnIndex = convertColumnIndexToModel(colIndex);

                try {
                    MemoryDasm memory=dataTableModelMemoryLow.getData()[rowIndex];
                    switch (dataTableModelMemoryLow.columns[realColumnIndex]) {
                        case ID:
                        if (!memory.isInside) tip="Memory outside of the program";
                        else if(memory.isCode) tip="Memory marked as code";
                        else if (memory.isData) tip="Memory marked as data";
                        else tip="Memory not marked as code or data";
                        break;
                        case DC:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.dasmComment;
                        break;
                        case UC:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.userComment;
                        break;
                        case DL:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.dasmLocation;
                        break;
                        case UL:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.userLocation;
                        break;
                        case UB:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip="<html>"+memory.userBlockComment.replace("\n", "<br>")+"</html>";
                        break;
                        case RE:
                        if (memory.type!=' ') {
                            MemoryDasm mem=dataTableModelMemoryLow.getData()[memory.related];
                            switch (memory.type) {
                                case '+':
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip=mem.userLocation+"+"+(memory.address-memory.related);
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip=mem.dasmLocation+"+"+(memory.address-memory.related);
                                else tip="$"+Shared.ShortToExe(mem.address)+"+"+(memory.address-memory.related);
                                break;
                                case '-':
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip=mem.userLocation+(memory.address-memory.related);
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip=mem.dasmLocation+(memory.address-memory.related);
                                else tip="$"+Shared.ShortToExe(mem.address)+(memory.address-memory.related);
                                break;
                                default:
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip="#"+memory.type+mem.userLocation;
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip="#"+memory.type+mem.dasmLocation;
                                else tip="#"+memory.type+"$"+Shared.ShortToExe(mem.address);
                            }
                        } else if (memory.dataType!=null) {
                            tip=memory.dataType.getDescription();
                        }
                        break;
                    }
                } catch (RuntimeException e1) {
                    //catch null pointer exception if mouse is over an empty line
                }
                return tip;
            }

        };
        jPanelSearchLow = new javax.swing.JPanel();
        jLabelSeachLow = new javax.swing.JLabel();
        jPanelTo = new javax.swing.JPanel();
        jPanelHigh = new javax.swing.JPanel();
        jLabelHigh = new javax.swing.JLabel();
        jScrollPaneHigh = new javax.swing.JScrollPane();
        jTableHigh = new javax.swing.JTable() {
            String[] hh={"Memory address location in Hex",
                "Disassembler automatic comment",
                "User manual comment",
                "Disassembler automatic label",
                "User manual label",
                "User global comment",
                "Related location and data type",
                "Value in memory"};
            @Override protected JTableHeader createDefaultTableHeader() {
                return new JTableHeader(columnModel) {
                    @Override public String getToolTipText(MouseEvent e) {
                        int col = columnAtPoint(e.getPoint());
                        int index = columnModel.getColumnIndexAtX(e.getPoint().x);
                        int realIndex = columnModel.getColumn(index).getModelIndex();
                        return hh[realIndex];
                    }
                };
            }

            //Implement table cell tool tips.
            public String getToolTipText(MouseEvent e) {
                String tip = null;
                java.awt.Point p = e.getPoint();
                int rowIndex = rowAtPoint(p);
                int colIndex = columnAtPoint(p);
                int realColumnIndex = convertColumnIndexToModel(colIndex);

                try {
                    MemoryDasm memory=dataTableModelMemoryHigh.getData()[rowIndex];
                    switch (dataTableModelMemoryHigh.columns[realColumnIndex]) {
                        case ID:
                        if (!memory.isInside) tip="Memory outside of the program";
                        else if(memory.isCode) tip="Memory marked as code";
                        else if (memory.isData) tip="Memory marked as data";
                        else tip="Memory not marked as code or data";
                        break;
                        case DC:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.dasmComment;
                        break;
                        case UC:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.userComment;
                        break;
                        case DL:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.dasmLocation;
                        break;
                        case UL:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip=memory.userLocation;
                        break;
                        case UB:
                        if ((Boolean)getValueAt(rowIndex, colIndex)) tip="<html>"+memory.userBlockComment.replace("\n", "<br>")+"</html>";
                        break;
                        case RE:
                        if (memory.type!=' ') {
                            MemoryDasm mem=dataTableModelMemoryHigh.getData()[memory.related];
                            switch (memory.type) {
                                case '+':
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip=mem.userLocation+"+"+(memory.address-memory.related);
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip=mem.dasmLocation+"+"+(memory.address-memory.related);
                                else tip="$"+Shared.ShortToExe(mem.address)+"+"+(memory.address-memory.related);
                                break;
                                case '-':
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip=mem.userLocation+(memory.address-memory.related);
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip=mem.dasmLocation+(memory.address-memory.related);
                                else tip="$"+Shared.ShortToExe(mem.address)+(memory.address-memory.related);
                                break;
                                default:
                                if (mem.userLocation!=null && !"".equals(mem.userLocation)) tip="#"+memory.type+mem.userLocation;
                                else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) tip="#"+memory.type+mem.dasmLocation;
                                else tip="#"+memory.type+"$"+Shared.ShortToExe(mem.address);
                            }
                        } else if (memory.dataType!=null) {
                            tip=memory.dataType.getDescription();
                        }
                        break;
                    }
                } catch (RuntimeException e1) {
                    //catch null pointer exception if mouse is over an empty line
                }
                return tip;
            }

        };
        jPanelSearchHigh = new javax.swing.JPanel();
        jLabelSearchHigh = new javax.swing.JLabel();
        jPanelTable = new javax.swing.JPanel();
        jPanelText = new javax.swing.JPanel();
        jLabelText = new javax.swing.JLabel();
        jPanelCmd = new javax.swing.JPanel();
        jLabelSize = new javax.swing.JLabel();
        jSpinnerSize = new javax.swing.JSpinner();
        jButtonApply = new javax.swing.JButton();
        jLabelPrefix = new javax.swing.JLabel();
        jTextFieldPrefix = new javax.swing.JTextField();
        jLabelDigit = new javax.swing.JLabel();
        jSpinnerDigit = new javax.swing.JSpinner();
        jScrollPaneTable = new javax.swing.JScrollPane();
        jTable = new javax.swing.JTable();
        wizardTableCellRenderer=new WizardTableCellRenderer(jSpinnerSize);
        jTable.setDefaultRenderer(String.class, wizardTableCellRenderer);
        jPanelDn = new javax.swing.JPanel();
        jButtonClose = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        jPanelUp.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        jLabelWizard.setText("Wizard for automatic < and > addresses creation");
        jPanelUp.add(jLabelWizard);

        getContentPane().add(jPanelUp, java.awt.BorderLayout.PAGE_START);

        jSplitPaneMain.setDividerLocation(450);
        jSplitPaneMain.setVerifyInputWhenFocusTarget(false);

        jPanelMem.setLayout(new java.awt.GridLayout(0, 2));

        jPanelFrom.setLayout(new java.awt.BorderLayout());

        jLabelLow.setText("LOW");
        jPanelLo.add(jLabelLow);

        jPanelFrom.add(jPanelLo, java.awt.BorderLayout.PAGE_START);

        jTableLow.setModel(dataTableModelMemoryLow);
        jTableLow.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jTableLow.setDefaultRenderer(Integer.class, memoryTableCellRenderer);
        jTableLow.getColumnModel().getColumn(0).setPreferredWidth(310);

        InputMap im = this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        ActionMap am = this.getRootPane().getActionMap();

        //add custom action
        im.put(KeyStroke.getKeyStroke("control D"), "searchLow");
        am.put("searchLow", new AbstractAction(){
            @Override
            public void actionPerformed(ActionEvent ae) {
                String addr=JOptionPane.showInputDialog("Search and go to a given HEX memory address");
                if (addr==null) return;

                try {
                    int pos=Integer.parseInt(addr,16);
                    if (pos<0 || pos>0xFFFF) return;

                    jTableLow.getSelectionModel().setSelectionInterval(pos, pos);
                    jTableLow.scrollRectToVisible(new Rectangle(jTableLow.getCellRect(pos, 0, true)));
                } catch (Exception e) {
                }
            }
        });

        ((InputMap)UIManager.get("Table.ancestorInputMap")).put(KeyStroke.getKeyStroke("control D"), "none");
        jTableLow.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTableLowMouseClicked(evt);
            }
        });
        jScrollPaneLow.setViewportView(jTableLow);

        jPanelFrom.add(jScrollPaneLow, java.awt.BorderLayout.CENTER);

        jLabelSeachLow.setText("CTRL+D search");
        jPanelSearchLow.add(jLabelSeachLow);

        jPanelFrom.add(jPanelSearchLow, java.awt.BorderLayout.PAGE_END);

        jPanelMem.add(jPanelFrom);

        jPanelTo.setLayout(new java.awt.BorderLayout());

        jLabelHigh.setText("HIGH");
        jPanelHigh.add(jLabelHigh);

        jPanelTo.add(jPanelHigh, java.awt.BorderLayout.NORTH);

        jTableHigh.setModel(dataTableModelMemoryHigh);
        jTableHigh.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jTableHigh.setDefaultRenderer(Integer.class, memoryTableCellRenderer);
        jTableHigh.getColumnModel().getColumn(0).setPreferredWidth(310);

        jTableHigh.getColumnModel().getColumn(0).setPreferredWidth(310);

        InputMap im1 = this.getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
        ActionMap am1 = this.getRootPane().getActionMap();

        //add custom action
        im1.put(KeyStroke.getKeyStroke("control F"), "searchHigh");
        am1.put("searchHigh", new AbstractAction(){
            @Override
            public void actionPerformed(ActionEvent ae) {
                String addr=JOptionPane.showInputDialog("Search and go to a given HEX memory address");
                if (addr==null) return;

                try {
                    int pos=Integer.parseInt(addr,16);
                    if (pos<0 || pos>0xFFFF) return;

                    jTableHigh.getSelectionModel().setSelectionInterval(pos, pos);
                    jTableHigh.scrollRectToVisible(new Rectangle(jTableHigh.getCellRect(pos, 0, true)));
                } catch (Exception e) {
                }
            }
        });

        ((InputMap)UIManager.get("Table.ancestorInputMap")).put(KeyStroke.getKeyStroke("control F"), "none");
        jTableHigh.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTableHighMouseClicked(evt);
            }
        });
        jScrollPaneHigh.setViewportView(jTableHigh);

        jPanelTo.add(jScrollPaneHigh, java.awt.BorderLayout.CENTER);

        jLabelSearchHigh.setText("CTRL+F search");
        jPanelSearchHigh.add(jLabelSearchHigh);

        jPanelTo.add(jPanelSearchHigh, java.awt.BorderLayout.PAGE_END);

        jPanelMem.add(jPanelTo);

        jSplitPaneMain.setLeftComponent(jPanelMem);

        jPanelTable.setLayout(new java.awt.BorderLayout());

        jPanelText.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        jLabelText.setText("Preview of (combined)  memory address ");
        jPanelText.add(jLabelText);

        jPanelTable.add(jPanelText, java.awt.BorderLayout.NORTH);

        jLabelSize.setText("Table size:");

        jSpinnerSize.setModel(new javax.swing.SpinnerNumberModel(256, 1, 256, 1));
        jSpinnerSize.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerSizeStateChanged(evt);
            }
        });

        jButtonApply.setText("Apply");
        jButtonApply.setToolTipText("Apply the selected table/labels in memory");
        jButtonApply.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonApplyActionPerformed(evt);
            }
        });

        jLabelPrefix.setText("Prefix:");

        jTextFieldPrefix.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextFieldPrefixFocusLost(evt);
            }
        });

        jLabelDigit.setText("Digit:");

        jSpinnerDigit.setModel(new javax.swing.SpinnerNumberModel(1, 1, 2, 1));
        jSpinnerDigit.setToolTipText("Min number of digits to use (can increase automatically)");
        jSpinnerDigit.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                jSpinnerDigitStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanelCmdLayout = new javax.swing.GroupLayout(jPanelCmd);
        jPanelCmd.setLayout(jPanelCmdLayout);
        jPanelCmdLayout.setHorizontalGroup(
            jPanelCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCmdLayout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(jLabelSize)
                .addGap(5, 5, 5)
                .addComponent(jSpinnerSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(31, 31, 31)
                .addComponent(jLabelPrefix)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldPrefix, javax.swing.GroupLayout.PREFERRED_SIZE, 55, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(32, 32, 32)
                .addComponent(jLabelDigit)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSpinnerDigit, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(118, 118, 118)
                .addComponent(jButtonApply))
        );
        jPanelCmdLayout.setVerticalGroup(
            jPanelCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCmdLayout.createSequentialGroup()
                .addGap(5, 5, 5)
                .addGroup(jPanelCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanelCmdLayout.createSequentialGroup()
                        .addGap(3, 3, 3)
                        .addComponent(jLabelSize))
                    .addGroup(jPanelCmdLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jSpinnerSize, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabelPrefix)
                        .addComponent(jTextFieldPrefix, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabelDigit)
                        .addComponent(jSpinnerDigit, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jButtonApply)))
        );

        jPanelTable.add(jPanelCmd, java.awt.BorderLayout.SOUTH);

        jScrollPaneTable.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        jScrollPaneTable.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        jScrollPaneTable.setPreferredSize(new java.awt.Dimension(700, 418));

        jTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null}
            },
            new String [] {
                "1", "2", "3", "4", "5", "6", "7", "8"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jTable.setRowSelectionAllowed(false);
        jScrollPaneTable.setViewportView(jTable);

        jPanelTable.add(jScrollPaneTable, java.awt.BorderLayout.CENTER);

        jSplitPaneMain.setRightComponent(jPanelTable);

        javax.swing.GroupLayout jPanelCnLayout = new javax.swing.GroupLayout(jPanelCn);
        jPanelCn.setLayout(jPanelCnLayout);
        jPanelCnLayout.setHorizontalGroup(
            jPanelCnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanelCnLayout.createSequentialGroup()
                .addComponent(jSplitPaneMain, javax.swing.GroupLayout.DEFAULT_SIZE, 1149, Short.MAX_VALUE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        jPanelCnLayout.setVerticalGroup(
            jPanelCnLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jSplitPaneMain, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 718, Short.MAX_VALUE)
        );

        getContentPane().add(jPanelCn, java.awt.BorderLayout.CENTER);

        jPanelDn.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));

        jButtonClose.setText("Close");
        jButtonClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCloseActionPerformed(evt);
            }
        });
        jPanelDn.add(jButtonClose);

        getContentPane().add(jPanelDn, java.awt.BorderLayout.PAGE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCloseActionPerformed
       setVisible(false);
    }//GEN-LAST:event_jButtonCloseActionPerformed

    private void jTableLowMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTableLowMouseClicked
      popolate(jTableLow.getSelectedRow(), jTableHigh.getSelectedRow());
    }//GEN-LAST:event_jTableLowMouseClicked

    private void jTableHighMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTableHighMouseClicked
      popolate(jTableLow.getSelectedRow(), jTableHigh.getSelectedRow());
    }//GEN-LAST:event_jTableHighMouseClicked

    private void jButtonApplyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonApplyActionPerformed
      apply(jTableLow.getSelectedRow(), jTableHigh.getSelectedRow(), (Integer)jSpinnerSize.getValue());
    }//GEN-LAST:event_jButtonApplyActionPerformed

    private void jSpinnerSizeStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSpinnerSizeStateChanged
      popolate(jTableLow.getSelectedRow(), jTableHigh.getSelectedRow());
    }//GEN-LAST:event_jSpinnerSizeStateChanged

    private void jSpinnerDigitStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_jSpinnerDigitStateChanged
        // TODO add your handling code here:
    }//GEN-LAST:event_jSpinnerDigitStateChanged

    private void jTextFieldPrefixFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextFieldPrefixFocusLost
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextFieldPrefixFocusLost

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(JWizardDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(JWizardDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(JWizardDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(JWizardDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                JWizardDialog dialog = new JWizardDialog(new javax.swing.JFrame(), true, null);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }        

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonApply;
    private javax.swing.JButton jButtonClose;
    private javax.swing.JLabel jLabelDigit;
    private javax.swing.JLabel jLabelHigh;
    private javax.swing.JLabel jLabelLow;
    private javax.swing.JLabel jLabelPrefix;
    private javax.swing.JLabel jLabelSeachLow;
    private javax.swing.JLabel jLabelSearchHigh;
    private javax.swing.JLabel jLabelSize;
    private javax.swing.JLabel jLabelText;
    private javax.swing.JLabel jLabelWizard;
    private javax.swing.JPanel jPanelCmd;
    private javax.swing.JPanel jPanelCn;
    private javax.swing.JPanel jPanelDn;
    private javax.swing.JPanel jPanelFrom;
    private javax.swing.JPanel jPanelHigh;
    private javax.swing.JPanel jPanelLo;
    private javax.swing.JPanel jPanelMem;
    private javax.swing.JPanel jPanelSearchHigh;
    private javax.swing.JPanel jPanelSearchLow;
    private javax.swing.JPanel jPanelTable;
    private javax.swing.JPanel jPanelText;
    private javax.swing.JPanel jPanelTo;
    private javax.swing.JPanel jPanelUp;
    private javax.swing.JScrollPane jScrollPaneHigh;
    private javax.swing.JScrollPane jScrollPaneLow;
    private javax.swing.JScrollPane jScrollPaneTable;
    private javax.swing.JSpinner jSpinnerDigit;
    private javax.swing.JSpinner jSpinnerSize;
    private javax.swing.JSplitPane jSplitPaneMain;
    private javax.swing.JTable jTable;
    private javax.swing.JTable jTableHigh;
    private javax.swing.JTable jTableLow;
    private javax.swing.JTextField jTextFieldPrefix;
    // End of variables declaration//GEN-END:variables

    /**
     * Popolate the table with addresses
     * 
     * @param rowLow low row position
     * @param rowHigh  high row position
     */
    private void popolate(int rowLow, int rowHigh) {
      int row=-1;
      TableModel model=jTable.getModel();  
      
      for (int i=0; i<256; i++) {
        if (i%8==0) row++;  
        model.setValueAt("", row, i%8);                
      }
      
      int size=(Integer)jSpinnerSize.getValue();
      
      if (hasError(rowLow, rowHigh, size)) return;
      
      int address;
      String label;
      MemoryDasm mem;
      
      row=-1;
      for (int i=0; i<size; i++) {
        if (i%8==0) row++;  
          
        address=(memory[rowLow+i].copy & 0xFF)+(memory[rowHigh+i].copy & 0xFF)*256;
        mem=memory[address];
        
        if (mem.userLocation!=null && !"".equals(mem.userLocation)) label=mem.userLocation;
        else if (mem.dasmLocation!=null && !"".equals(mem.dasmLocation)) label=mem.dasmLocation;
        else label="$"+Shared.ShortToExe((int)address);        
        model.setValueAt(label, row, i%8);                               
      }
    }
    
    /**
     * Apply the selected table to relative relation in memory
     * 
     * @param rowLow row low position 
     * @param rowHigh roh high position
     * @param size size to use for table
     */
    private void apply(int rowLow, int rowHigh, int size) {
      if (hasError(rowLow, rowHigh, size)) return;
      
      
      int address;
      MemoryDasm mem;
      
      for (int i=0; i<size; i++) {
          
        address=(memory[rowLow+i].copy & 0xFF)+(memory[rowHigh+i].copy & 0xFF)*256;
        mem=memory[address];
        
        memory[rowLow+i].related=address;          
        memory[rowLow+i].type='<';

        memory[rowHigh+i].related=address;       
        memory[rowHigh+i].type='>';          
      }
      
      JOptionPane.showMessageDialog(this, "Table relation applied into memory");
    }

    
    /**
     * Check if has error
     * 
     * @param rowLow low row position
     * @param rowHigh high row position
     * @param size the size of table
     * @return true if it has error
     */
    private boolean hasError(int rowLow, int rowHigh, int size) {
      if (rowLow==-1 || rowHigh==-1) return true;            
      
      if (rowLow+size>0xFFFF) {
        JOptionPane.showMessageDialog(this, "Size is too big for this low address");
        return true;      
      }
      
      if (rowHigh+size>0xFFFF) {
        JOptionPane.showMessageDialog(this, "Size is too big for this high address");
        return true;      
      }

      if (rowLow<rowHigh && rowHigh<rowLow+size) {
        JOptionPane.showMessageDialog(this, "High address is inside low address table");
        return true; 
      }
      
      if (rowHigh<rowLow && rowLow<rowHigh+size) {
        JOptionPane.showMessageDialog(this, "Low address is inside high address table");
        return true; 
      }
      return false;
    }
}
